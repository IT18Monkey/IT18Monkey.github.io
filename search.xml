<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java泛型（Generics）]]></title>
    <url>%2F2018%2F08%2F05%2Fjava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[作者：lkd_whh博客地址：拔剑少年转载请注明出处 泛型的好处 编译时期的强类型检查。有利于提早发现问题，解决问题。 不用再使用类型强转。 能够利用泛型编写简单易读的通用代码。 ####泛型的使用 泛型通常命名规则 E - Element K - Key N - Number T - Type V - Value S,U,V 等等。- 第二，第三，第四类型。 泛型类的定义和使用。 以最常用的Arraylist为例，我们看下它的定义和使用。当我实例化时在&lt;&gt;中传入的类型为Integer时，集合中就无法再放入其他类型的元素了，从集合中取得元素时也不用再强转。（注意：泛型不支持基本类型，但是我们可以使用它的包装类型） 1234567//定义public class ArrayList&lt;E&gt;&#123;&#125;//使用ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();list.add(1);list.add(2l);//编译错误,无法插入Long类型Integer integer=list.get(0);//能够直接确定取得的是Integer类型 泛型方法。 声明方法和泛型类相似。 作用域仅限于声明的方法内。 静态方法，非静态方法，构造方法都可以使用。 类型参数区段必须出现在方法返回类型之前。 12345678910111213141516171819202122/** * 泛型构造方法格式 * @param t * @param &lt;T&gt; */ public &lt;T&gt; Generics(T t) &#123; &#125; /** * 非静态泛型方法格式 * @param t * @param &lt;T&gt; * @return */ public &lt;T&gt; T getNonStatic(T t) &#123; &#125; /** * 静态泛型方法格式 * @param t * @param &lt;T&gt; */ public static &lt;T&gt; voTid getStatic(T t) &#123; &#125; 类型限定。关键字extends,限制传入的类型参数必须为指定的类型或其子类型。 12345678910111213141516171819/** * 单个类型限定 * @param t * @param &lt;V&gt; */public static &lt;V extends Integer&gt; void singleBondedType(V t) &#123; System.out.println(t.intValue());&#125;/** * 多个类型限定，需要同时满足条件。 * 类型限定声明中类需要声明在接口前面 * @param t * @param &lt;V&gt; */public static &lt;V extends Integer &amp; Comparator&gt; void multipleBondedType(V t) &#123; System.out.println(t.intValue()); System.out.println(t.compare(1,2));&#125; 通配符（Wildcards） 向上有界通配符（Upper Bounded Wildcards） 无界通配符（Unbounded Wildcards） 向下有界通配符（Lower Bounded Wildcards） 1234567891011121314151617181920/** * 上有界通配符 * @param list */ public static void upperBoundedWildcards(List&lt;? extends String&gt; list)&#123; &#125; /** * 无界通配符 * @param list */ public static void unboundedWildcards(List&lt;?&gt; list)&#123; &#125; /** * 下有界通配符 * @param list */ public static void lowerBoundedWildcards(List&lt;? super Integer&gt; list)&#123; &#125; ps: 你可以用通配符指定一个上界，也可以指定一个下界，但不能同时指定。 泛型的限制 不接受基本类型当作参数。 不能通过new泛型来实例化对象，但是可以通过反射来实现。 不能声明静态泛型变量。 不能对泛型参数使用cast或instanceof。 不能创建泛型型数组，比如 1List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2]; // 编译错误 由于类型擦除机制，不能通过泛型重载方法。 123//编译错误 public void print(Set&lt;String&gt; strSet) &#123; &#125;public void print(Set&lt;Integer&gt; intSet) &#123; &#125; ​]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>泛型</tag>
        <tag>Generics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 5，6，7，8，9，10新特性吐血总结]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[作者：lkd_whh博客地址：拔剑少年转载请注明出处 java5 泛型 (Generics) 1List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); 增强循环（Enhanced for Loop） 1234int[] array = &#123;1, 2, 3, 4, 5&#125;;for (int i : array) &#123; System.out.println(i);&#125; 自动封箱拆箱(Autoboxing/Unboxing )。八大基本类型和它们的包装类能够自动的相互转换。 枚举(Typesafe Enums)。 ps:枚举是一种实现线程安全的单例模式的好方式。 123456enum TestEnum&#123; one, two; TestEnum() &#123; &#125; &#125; 可变参数 (Varargs) 语法：(type... arguments) 可变参数本质仍然是用一个数组存储参数，只是java隐藏了这一过程。需要注意的是如果一个方法声明中含有可变参数，那必须放在最后一个位置。 123456789101112/** * 可变参数测试 * * @param args */ public static void testVarargs(String... args) &#123; //本质就是个数组 System.out.println(args[1]); for (String arg : args) &#123; System.out.println(arg); &#125; &#125; 静态导入（Static Import）。通过import类来使用类里的静态变量或方法（直接通过名字，不需要加上类名.）,简化了代码的书写。 1234//单个导入import static java.lang.Math.PI;//批量导入import static java.lang.Math.*; ps:过去的版本中只能通过继承类或实现接口才能使用。 注解（Annotations）。关键字@interface。 1234567891011//注释注解的注解又叫做元注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyAnnotations &#123; //注解内可以添加方法，也可以不添加 //注解方法的返回值只能是基本类型，String，Class类,枚举,注解,可以有默认值。 int id(); String name() default "whh"; Class classType(); TestEnum enumType();&#125; 新的线程模型和并发库（java.util.concurrent)。 java6 集合框架增强。 为了更好的支持双向访问集合。添加了许多新的类和接口。 新的数组拷贝方法。Arrays.copyOf和Arrays.copyOfRange 12//以下为添加的新接口和类Deque,BlockingDeque,NavigableSet,NavigableMap,ConcurrentNavigableMap，ArrayDeque， ConcurrentSkipListSet ,ConcurrentSkipListMap,ConcurrentSkipListMap ,AbstractMap.SimpleEntry ,AbstractMap.SimpleImmutableEntry Scripting. 可以让其他语言在java平台上运行。 java6包含了一个基于Mozilla Rhino实现的javascript脚本引擎。 支持JDBC4.0规范。 java7 二进制前缀0b或者0B。整型（byte, short, int, long）可以直接用二进制表示。 123//二进制字面值前缀0b 或0B int i = 0b010;//10进制值为2 int j = 0B010; 字面常量数字的下划线。用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾。 12//数字间的下划线不影响实际值 int k = 1_1;//值为11 switch 支持String类型。 泛型实例化类型自动推断。 12Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;(); // 之前Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;(); // 现在 try-with-resources语句。 1234567 /* * 声明在try括号中的对象称为资源，在方法执行完毕后会被自动关闭,相对与之前必须在finally关闭资源，这一特性大大提高了代码的简洁性。 * 所有实现java.lang.AutoCloseable接口的类都作为资源被自动关闭。 */ try (BufferedReader reader=new BufferedReader(new FileReader("d:1.txt")))&#123; return reader.readLine();&#125; 单个catch中捕获多个异常类型（用| 分割）并通过改进的类型检查重新抛出异常。 java8 lambada表达式(Lambda Expressions)。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中)。 方法引用（Method references）。方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法（Default methods）。默认方法允许将新功能添加到库的接口中，并确保兼容实现老版本接口的旧有代码。 重复注解（Repeating Annotations）。重复注解提供了在同一声明或类型中多次应用相同注解类型的能力。 类型注解（Type Annotation）。在任何地方都能使用注解，而不是在声明的地方。 类型推断增强。 方法参数反射（Method Parameter Reflection）。 Stream API 。新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。Stream API集成到了Collections API里。 HashMap改进，在键值哈希冲突时能有更好表现。 Date Time API。加强对日期和时间的处理。 java.util 包下的改进，提供了几个实用的工具类。 并行数组排序。 标准的Base64编解码。 支持无符号运算。 java.util.concurrent 包下增加了新的类和方法。 java.util.concurrent.ConcurrentHashMap 类添加了新的方法以支持新的StreamApi和lambada表达式。 java.util.concurrent.atomic 包下新增了类以支持可伸缩可更新的变量。 java.util.concurrent.ForkJoinPool类新增了方法以支持 common pool。 新增了java.util.concurrent.locks.StampedLock类，为控制读/写访问提供了一个基于性能的锁，且有三种模式可供选择。 HotSpot 删除了 永久代（PermGen）. 方法调用的字节码指令支持默认方法。 java9 java模块系统 （Java Platform Module System）。 新的版本号格式。$MAJOR.$MINOR.$SECURITY.$PATCH java shell，交互式命令行控制台。 在private instance methods方法上可以使用@SafeVarargs注解。 diamond语法与匿名内部类结合使用。 下划线不能用在变量名中。 支持私有接口方法(您可以使用diamond语法与匿名内部类结合使用)。 Javadoc 简化Doclet API。 支持生成HTML5格式。 加入了搜索框,使用这个搜索框可以查询程序元素、标记的单词和文档中的短语。 支持新的模块系统。 JVM 增强了Garbage-First(G1)并用它替代Parallel GC成为默认的垃圾收集器。 统一了JVM 日志，为所有组件引入了同一个日志系统。 删除了JDK 8中弃用的GC组合。（DefNew + CMS，ParNew + SerialOld，Incremental CMS）。 properties文件支持UTF-8编码,之前只支持ISO-8859-1。 支持Unicode 8.0，在JDK8中是Unicode 6.2。 java10 局部变量类型推断（Local-Variable Type Inference） 12345678910//之前的代码格式URL url = new URL("http://www.oracle.com/"); URLConnection conn = url.openConnection(); Reader reader = new BufferedReader( new InputStreamReader(conn.getInputStream()))//java10中用var来声明变量var url = new URL("http://www.oracle.com/"); var conn = url.openConnection(); var reader = new BufferedReader( new InputStreamReader(conn.getInputStream())); var是一个保留类型名称，而不是关键字。所以之前使用var作为变量、方法名、包名的都没问题，但是如果作为类或接口名，那么这个类和接口就必须重命名了。 var的使用场景主要有以下四种： 本地变量初始化。 增强for循环中。 传统for循环中声明的索引变量。 Try-with-resources 变量。​ 参考链接： JDK Release Notes What’s New in JDK 8 What’s New in JDK 9 JDK 10 Release Notes]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>jdk</tag>
        <tag>java新特性</tag>
      </tags>
  </entry>
</search>
