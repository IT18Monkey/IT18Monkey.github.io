<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅尝docker]]></title>
    <url>%2F2019%2F02%2F17%2F%E6%B5%85%E5%B0%9Ddocker%2F</url>
    <content type="text"><![CDATA[作者：拔剑少年 简书地址：https://www.jianshu.com/u/dad4d9675892博客地址：https://it18monkey.github.io转载请注明出处 什么是docker​ 我们先来看下官方给出的说法 Package Software into Standardized Units for Development, Shipment and Deployment ​ docker是一个工具，一个用于软件打包的工具。那这个打包工具有什么特殊的呢，他能将运行一个应用所需要的所有东西，包括程序代码、系统工具、系统库和系统设置都打成一个包。这个包被称之为容器。 我个人更倾向于将他描述为一个轻量级的虚拟机，因为它和虚拟机有着很多相似之处。 docker与虚拟机的区别 上面两幅图展示了用虚拟机和docker运行程序的大体结构。让我们从下往上来对比。 先看虚拟机这边： 最底层是某种类型的基础设施，可能是一台个人电脑，或者是服务器。往上，是一个名为hypervisor的虚拟机管理程序，在这之上运行客户操作系统，也就是虚拟系统，每个虚拟系统都是相互隔离的。然后,所有的应用程序都运行在虚拟系统上。这里提下，虚拟机也是可以运行在操作系统上的。它分为两种，一种直接运行在系统硬件上，创建硬件全仿真实例，被称为裸机型。一种运行在传统操作系统上，同样创建的是硬件全仿真实例，被称为“托管（宿主）”型。 再看docker这边： 最底层和虚拟机一样，是某种类型的基础设施，可能是一台个人电脑，或者是服务器。往上是一个宿主操作系统，可能是windows或者是linux。也就是说docker不能直接运行在系统硬件上。目前来说支持linux和windows。在这个操作宿主操作系统上，我们安装一个docker，而我们的应用程序全部都运行在docker上，由docker来统一管理。每个应用程序都是相互隔离的。 docker和虚拟机最大的区别就是他们的隔离级别不同。虚拟机是硬件级别的隔离，而docker只到进程级别。这一点也比较影响我们选择使用docker或是虚拟机。当然他们也不是互斥的，完全可以根据实际需要相互结合。 为什么要用docker作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源 更快速的启动时间 一致的运行环境 持续交付和部署 更轻松的迁移 更轻松的维护和扩展 docker基本概念 镜像 我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器 镜像（ Image ）和容器（ Container ）的关系，就像是面向对象程序设计中的类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，DockerRegistry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库（ Repository ）；每个仓库可以包含多个标签（ Tag ）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 Docker Registry 分为公开和私有两种，用户可以根据自己的需要搭配使用。 Docker常用命令镜像仓库操作 docker login/logout 登陆/登出到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub。 格式：docker login [选项][SERVER] ,docker logout [选项][SERVER]。 docker pull 从Docker Registry获取镜像。格式：docker pull [选项][Docker Registry 地址[:端口号]/]仓库名[:标签]。 docker push 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库。格式：docker push [选项] 仓库名[:标签]。 docker search 从Docker Hub查找镜像。格式docker search [选项] 关键字。 镜像操作 docker images 列出本地镜像。格式：docker images [选项][仓库名[:标签]]。 docker run 创建一个新的容器并运行一个命令。格式：docker run [选项] 镜像名[命令][参数]。 docker rmi 删除本地一个或多少镜像。格式：docker rmi [选项] 镜像名[镜像名...]。 docker build 使用 Dockerfile 创建镜像。格式：docker build [选项] 路径 | URL | -。 docker history查看指定镜像的创建历史。格式：docker history [选项] 镜像名。 容器操作 docker ps列出容器。格式：docker ps [选项]。 docker inspect 获取容器/镜像的元数据。docker inspect [选项] 名称|ID。 docker start/stop/restartdocker start :启动一个或多个已经被停止的容器。格式：docker start [选项] 容器名[ [容器名...]]。docker stop :停止一个运行中的容器。docker stop [选项] 容器名[ [容器名...]]。docker restart :重启容器。docker restart [选项] 容器名[ [容器名...]]。 docker kill杀掉一个运行中的容器。docker kill [选项] 容器名 [容器名...]。 docker rm删除一个或多个容器。docker rm [选项] 容器名[容器名...] 技术要点 UnionFS与镜像分层存储 所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。主要有以下几种实现：autfs,overlayfs。下图展示了overlayfs的基本结构 其中lower dirA / lower dirB目录和upper dir目录为来自底层文件系统的不同目录，用户可以自行指定，内部包含了用户想要合并的文件和目录，merge dir目录为挂载点。当文件系统挂载后，在merge目录下将会同时看到来自各lower和upper目录下的内容，并且用户也无法（无需）感知这些文件分别哪些来自lower dir，哪些来自upper dir，用户看见的只是一个普通的文件系统根目录而已（lower dir可以有多个也可以只有一个）。 虽然overlayfs将不同的各层目录进行合并，但是upper dir和各lower dir这几个不同的目录并不完全等价，存在层次关系。首先当upper dir和lower dir两个目录存在同名文件时，lower dir的文件将会被隐藏，用户只能看见来自upper dir的文件，然后各个lower dir也存在相同的层次关系，较上层屏蔽叫下层的同名文件。除此之外，如果存在同名的目录，那就继续合并（lower dir和upper dir合并到挂载点目录其实就是合并一个典型的例子）。 各层目录中的upper dir是可读写的目录，当用户通过merge dir向时其中一个来自upper dir的文件写入数据时，那数据将直接写入upper dir下原来的文件中，删除文件也是同理；而各lower dir则是只读的，在overlayfs挂载后无论如何操作merge目录中对应来自lower dir的文件或目录，lower dir中的内容均不会发生任何的改变。既然lower dir是只读的，那当用户想要往来自lower层的文件添加或修改内容时，overlayfs首先会的拷贝一份lower dir中的文件副本到upper dir中，后续的写入和修改操作将会在upper dir下的copy-up的副本文件中进行，lower dir原文件被隐藏。 以上就是overlayfs最基本的特性，简单的总结为以下3点：（1）上下层同名目录合并；（2）上下层同名文件覆盖；（3）lower dir文件写时拷贝。这三点对用户都是不感知的。 Linux Namespace 为了提供更加精细的资源分配管理机制，Linux给出了namespace解决方法。Docker利用这一技术隔离容器的运行环境。 linux内核实现了六种namespace。列表如下： | namespace | 引入的相关内核版本 | 被隔离的全局系统资源 | 在容器语境下的隔离效果 || ———————- | ———————————— | ———————————————————— | ———————————————————— || Mount namespaces | Linux 2.4.19 | 文件系统挂接点 | 每个容器能看到不同的文件系统层次结构 || UTS namespaces | Linux 2.6.19 | nodename 和 domainname | 每个容器可以有自己的 hostname 和 domainame || IPC namespaces | Linux 2.6.19 | 特定的进程间通信资源，包括System V IPC和 POSIX message queues | 每个容器有其自己的 System V IPC 和 POSIX 消息队列文件系统，因此，只有在同一个 IPC namespace 的进程之间才能互相通信 || PID namespaces | Linux 2.6.24 | 进程 ID 数字空间 （process ID number space） | 每个 PID namespace 中的进程可以有其独立的 PID； 每个容器可以有其 PID 为 1 的root 进程；也使得容器可以在不同的 host 之间迁移，因为 namespace 中的进程 ID 和 host 无关了。这也使得容器中的每个进程有两个PID：容器中的 PID 和 host 上的 PID。 || Network namespaces | 始于Linux 2.6.24 完成于 Linux 2.6.29 | 网络相关的系统资源 | 每个容器用有其独立的网络设备，IP 地址，IP 路由表，/proc/net 目录，端口号等等。这也使得一个 host 上多个容器内的同一个应用都绑定到各自容器的 80 端口上。 || User namespaces | 始于 Linux 2.6.23 完成于 Linux 3.8) | 用户和组 ID 空间 | 在 user namespace 中的进程的用户和组 ID 可以和在 host 上不同； 每个 container 可以有不同的 user 和 group id；一个 host 上的非特权用户可以成为 user namespace 中的特权用户； | Linux namespace 的概念说简单也简单说复杂也复杂。简单来说，我们只要知道，处于某个 namespace中的进程，能看到独立的它自己的隔离的某些特定系统资源；复杂来说，可以去看看 Linux 内核中实现 namespace 的原理。 Linux CGroups Docker 容器使用 linux namespace 来隔离其运行环境，使得容器中的进程看起来就像爱一个独立环境中运行一样。但是，光有运行环境隔离还不够，因为这些进程还是可以不受限制地使用系统资源，比如网络、磁盘、CPU以及内存等。关于其目的，一方面，是为了防止它占用了太多的资源而影响到其它进程；另一方面，在系统资源耗尽的时候，linux 内核会触发 OOM，这会让一些被杀掉的进程成了无辜的替死鬼。因此，为了让容器中的进程更加可控，Docker 使用 Linux cgroups 来限制容器中的进程允许使用的系统资源。 目前 docker 已经几乎支持了所有的 cgroups 资源，可以限制容器对包括 network，device，cpu 和 memory 在内的资源的使用 我们可以通过给docker run 命令传参来控制分配容器的资源。Docker run 命令中 cgroups 相关命令如下： 123456789101112131415161718192021222324block IO:--blkio-weight value Block IO (relative weight), between 10 and 1000--blkio-weight-device value Block IO weight (relative device weight) (default [])--cgroup-parent string Optional parent cgroup for the containerCPU:--cpu-percent int CPU percent (Windows only)--cpu-period int Limit CPU CFS (Completely Fair Scheduler)period--cpu-quota int Limit CPU CFS (Completely Fair Scheduler) quota-c, --cpu-shares int CPU shares (relative weight)--cpuset-cpus string CPUs in which to allow execution (0-3, 0,1)--cpuset-mems string MEMs in which to allow execution (0-3, 0,1)Device: --device Add a host device to the container--device-cgroup-rule Add a rule to the cgroup allowed devices list--device-read-bps Limit read rate (bytes per second) from a device--device-read-iops Limit read rate (IO per second) from a device--device-write-bps Limit write rate (bytes per second) to a device--device-write-iops Limit write rate (IO per second) to a deviceMemory: --kernel-memory string Kernel memory limit--memory , -m Memory limit--memory-reservation Memory soft limit--memory-swap Swap limit equal to memory plus swap: ‘-1’ to enable unlimited swap--memory-swappiness Tune container memory swappiness (0 to 100)]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化-EXPLAIN（mysql版本8.0）]]></title>
    <url>%2F2018%2F08%2F08%2FMySQL%E4%BC%98%E5%8C%96-EXPLAIN%2F</url>
    <content type="text"><![CDATA[作者：拔剑少年 简书地址：https://www.jianshu.com/u/dad4d9675892博客地址：https://it18monkey.github.io转载请注明出处 ​ Explain命令是MySQL提供的内置命令，它的作用是向我们展示MySQL是如何执行sql语句的。SELECT, DELETE, INSERT, REPLACE, UPDATE 语句都可以使用Explain命令。 ​ EXPLAIN为SELECT语句中使用的每个table返回一行信息。它以MySQL在处理语句时的读取顺序列出所有的table。MySQL使用嵌套循环的方式解决所有的表连接（join）。这意味着MySQL从第一个table读取一行，然后在第二个table、第三个table中查找匹配的行，以此类推。当所有的table都被处理过时，MySQL会输出所选的列并在所有的table中进行反向跟踪，直到找到一个有更多匹配行的table。从该table中读取下一行，并继续处理下一个table。 ​ 理解Explain输出的信息含义对SQL语句的优化有着至关重要的作用。 下面让我们详细解析下Explain命令输出的各字段的含义。 Explain 输出的列： 列名 JSON 名(FORMAT=JSON) 含义 id select_id SELECT 语句的id select_type 无 SELETE 语句的类型 table table_name 表名 partitions partitions 分区 type access_type join 类型 possible_keys possible_keys 可供选择使用的索引 key key 实际使用的索引 key_len key_length 实际使用索引的长度 ref ref 与索引比较的列 rows rows 预估检测行数 filtered filtered 依据表条件过滤行占比 Extra 无 其他信息 id SELECT的标识符。这是查询中的SELECT的序号。如果当前行引用了其他行的联合结果，则该值为空。举个例子，当table列显示&lt;unionM,N&gt;时，表示该行引用了id值为M和N的行的联合结果，这个时候id列的值就会为空。 如下sql： 1EXPLAIN SELECT *FROM(SELECT 2 UNION ALL SELECT 3 )t; 执行结果： select_type SELECT的类型，下表中展示了所有可能的值及其含义。 名称 JSON 名 含义 SIMPLE 无 简单的SELECT(没有使用UNION或者子查询) PRIMARY 无 最外层的查询 UNION 无 在一个UNION中第二或后面的SELECT语句 DEPENDENT UNION dependent (true) 在一个UNION中第二或后面的SELECT语句，并且依赖于外层查询 UNION RESULT union_result UNION的结果 SUBQUERY 无 子查询中的第一个SELECT DEPENDENT SUBQUERY dependent (true) 子查询中的第一个SELECT，并且依赖于外层查询 DERIVED 无 派生表（Derived table） MATERIALIZED materialized_from_subquery 实例化子查询（Materialized subquery） UNCACHEABLE SUBQUERY cacheable (false) 不能缓存结果的子查询，并且必须为外部查询的每一行重新计算结果 UNCACHEABLE UNION cacheable (false) 在一个UNCACHEABLE SUBQUERY的UNION语句中第二或后面的SELECT语句 DEPENDENT通常意味着使用了关联子查询。 DEPENDENT SUBQUERY 不同于 UNCACHEABLE SUBQUERY 。对于DEPENDENT SUBQUERY，对来自其外部上下文的每一组变量的不同值只重新计算一次子查询。对于UNCACHEABLE SUBQUERY，将会为外层上下文的每一行重新计算子查询。 对于非查询语句，select_type的值为语句类型。比如，对于一个DELETE语句，值为DELETE table 当前行引用的表名，除此之外也可能是以下几种值： &lt;union*M*,*N*&gt;：该行引用了id值为M和N的行的联合结果 &lt;derived*N*&gt;：该行引用了id值为N的行的派生表结果。比如引用了从子查询中生成的派生表。 &lt;subquery*N*&gt;：该行引用了id值为N的行的实例化子查询结果。 partitions 查询语句将从其中匹配记录的分区。对于非分区表，值为null。 type 本列用于向我们展示MySQL使用哪种方式join当前表的。下面按照最好到最坏的顺序详细解析可能出现的值。 system 该表只有一行数据。这种类型是下面const类型的一种特例。 const 该表最多只有一行数据被匹配，在查询开始时就会被读取。因为只有一行，所以这一行中列的值可以被优化器的其他部分视为常量。const表非常快，因为它们只需要读取一次。 当把一个表的主键或唯一索引和一个常量值作比较时，const就会被使用。下面的语句中，t1就可以被作为一个const表。 12SELECT * FROM t1 WHERE id=1;SELECT * FROM t2 WHERE unique_index_part1=1 and unique_index_part1=2; eq_ref 在与前一个表的每一行做联合时，只需要从该表中读取一行。除了system和const类型，这个是最好的join类型。当一个join语句中使用了主键或一个非空唯一索引的全部部分时，join类型就为eq_ref。 eq_ref可用于使用=运算符进行比较的索引列。比较值可以是一个常量，也可以是这个表之前读取的表中的列。 123456SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column;SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; ref 在与前表的每个行组合中，从该表中读取具有匹配索引值的所有行。当join仅仅使用一个索引的左前缀，或者使用的索引不是一个主键，又或者不是唯一索引，ref就会被使用。如果使用的索引匹配的行数很少，这也不失为一个很好的join类型。 eq_ref可用于使用=或&lt;=&gt;运算符进行比较的索引列。 12345678SELECT * FROM ref_table WHERE key_column=expr;SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column;SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; fulltext 使用全文索引执行join ref_or_null 这个join类型和ref有点像，但是对于包含null值行，MySQL会做一个额外的查询。这种join类型优化最常用于解析子查询。 12SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL; index_merge 这个join类型表示使用了索引合并优化。这个时候，key列显示了一系列使用到的索引，key_len显示了使用到的索引的最长键长。 unique_subquery 在以下形式的某些in子查询中，这个join类型会替代eq_ref。 1value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery只是一个索引查找函数，它完全替代了子查询以提高效率。 index_subquery 这个join类型和unique_subquery有些类似。它在子查询中替换，但在以下形式的子查询中适用于非唯一索引: 1value IN (SELECT key_column FROM single_table WHERE some_expr) range 当使用一个索引去选择行时只检索了给定范围的行。key列显示了使用了哪个索引，key_len显示了使用到的索引的最长键长。当join类型为range时，ref列值为null。 range可用于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;,BETWEEN, LIKE, IN() 运算符和一个常量进行比较的索引列。 1234567891011SELECT * FROM tbl_name WHERE key_column = 10;SELECT * FROM tbl_name WHERE key_column BETWEEN 10 and 20;SELECT * FROM tbl_name WHERE key_column IN (10,20,30);SELECT * FROM tbl_name WHERE key_part1 = 10 AND key_part2 IN (10,20,30) index 这个join类型和ALL相似，区别是扫描了索引数。以下两种情况： 当索引是一个覆盖索引，即包含(或覆盖)所有需要查询的字段的值，那么就只需要扫描索引树而无需回表，这个时候Extra列的值就会为Using index。index类型通常要比ALL类型要快，因为索引的长度通常要比表数据小得多。 按索引顺序查找数据行来执行全表扫描，这个时候Extra列的值不会为Using index。 ALL 为了和前表的每一行做组合而全表扫描。这种类型通常不太好，应当尽量避免。我们可以通过给表添加索引来避免这种情况。 possible_keys 这一列显示了可供MySQL选择用来查询使用的所有索引。需要注意的是其中的一些索引在实际运行时可能不会被使用。 如果这一列为null，那就表示没有想关的索引。这个时候，可以检查where子句引用的列是否适合建立索引，通过建立合适的索引增强执行性能。索引建立完成后，可以再次执行EXPLAIN查看效果。 想要知道表已经建立了哪些索引，可以通过SHOW INDEX FROM table_name查看。 key 本列显示的MySQL实际选择使用的索引。如果本列为空，则表示MySQL没有找到索引来提升执行效率。 这个索引可能不在possible_keys里。如果所有possible_keys索引都不适合查找行，但是其他有个索引包含了查询语句列举出的所有的列,就会发生这种情况，换句话说，这个索引覆盖了查询列。尽管它不能用来确定要检索哪些行，但扫描索引的效率比扫描数据行要高。 在InnoDB引擎中，即使查询列包含主键，辅助索引也可能会覆盖所选列。因为InnoDB将主键值存储在每个辅助索引中。 我们可以通过在查询语句中使用FORCE INDEX, USE INDEX, IGNORE INDEX 来强制MySQL使用或忽略possible_keys列中列出的索引。 key_len 本列显示了MySQL决定使用的索引的长度。本列的值能够使你确定MySQL实际使用了复合索引的多少部分。如果key列的值为null，那么key_len列的值也为null。 由于索引存储格式，一个允许空值的列，索引长度要比非空列要长。 ref 本列显示了哪一列或那个常量被用来和key列中的索引做比较的从而从表中筛选行。 如果值为func,表明使用了某些函数的结果。这个函数实际上可能是一个运算符，比如算术运算符 。 rows 本列表示MySQL认为执行查询语句时必须查找的行数。在InnoDB引擎中，这个数值是个预估值，可能会不精确。 filtered本列表示将被表条件过滤的表行的估计百分比。最大值为100，这意味着没有对行进行筛选。 Extra 本列展示了MySQL解析查询时一些额外的信息。下面介绍下本列可能出现的值。 const row not found Deleting all rows Distinct FirstMatch Full scan on NULL key Impossible HAVING Impossible WHERE Impossible WHERE noticed after reading const tables LooseScan No matching min/max row no matching row in const table No matching rows after partition pruning No tables used Not exists Plan isn’t ready yet Range checked for each record (index map: N) Recursive Select tables optimized away Start temporary, End temporary Using filesort Using index Using index condition Using index for group-by Using index for skip scan Using join buffer Using MRR Using sort_union(…), Using union(…), Using intersect(…) Using where Using where with pushed condition Zero limit]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Explain</tag>
        <tag>sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java泛型（Generics）]]></title>
    <url>%2F2018%2F08%2F05%2Fjava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[作者：拔剑少年 简书地址：https://www.jianshu.com/u/dad4d9675892博客地址：https://it18monkey.github.io转载请注明出处 泛型的好处 编译时期的强类型检查。有利于提早发现问题，解决问题。 不用再使用类型强转。 能够利用泛型编写简单易读的通用代码。 泛型的使用 泛型通常命名规则 E - Element K - Key N - Number T - Type V - Value S,U,V 等等。- 第二，第三，第四类型。 泛型类的定义和使用。 以最常用的Arraylist为例，我们看下它的定义和使用。当我实例化时在&lt;&gt;中传入的类型为Integer时，集合中就无法再放入其他类型的元素了，从集合中取得元素时也不用再强转。（注意：泛型不支持基本类型，但是我们可以使用它的包装类型） 1234567//定义public class ArrayList&lt;E&gt;&#123;&#125;//使用ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();list.add(1);list.add(2l);//编译错误,无法插入Long类型Integer integer=list.get(0);//能够直接确定取得的是Integer类型 泛型方法。 声明方法和泛型类相似。 作用域仅限于声明的方法内。 静态方法，非静态方法，构造方法都可以使用。 类型参数区段必须出现在方法返回类型之前。 12345678910111213141516171819202122/** * 泛型构造方法格式 * @param t * @param &lt;T&gt; */ public &lt;T&gt; Generics(T t) &#123; &#125; /** * 非静态泛型方法格式 * @param t * @param &lt;T&gt; * @return */ public &lt;T&gt; T getNonStatic(T t) &#123; &#125; /** * 静态泛型方法格式 * @param t * @param &lt;T&gt; */ public static &lt;T&gt; voTid getStatic(T t) &#123; &#125; 类型限定。关键字extends,限制传入的类型参数必须为指定的类型或其子类型。 12345678910111213141516171819/** * 单个类型限定 * @param t * @param &lt;V&gt; */public static &lt;V extends Integer&gt; void singleBondedType(V t) &#123; System.out.println(t.intValue());&#125;/** * 多个类型限定，需要同时满足条件。 * 类型限定声明中类需要声明在接口前面 * @param t * @param &lt;V&gt; */public static &lt;V extends Integer &amp; Comparator&gt; void multipleBondedType(V t) &#123; System.out.println(t.intValue()); System.out.println(t.compare(1,2));&#125; 通配符（Wildcards） 向上有界通配符（Upper Bounded Wildcards） 无界通配符（Unbounded Wildcards） 向下有界通配符（Lower Bounded Wildcards） 1234567891011121314151617181920/** * 上有界通配符 * @param list */ public static void upperBoundedWildcards(List&lt;? extends String&gt; list)&#123; &#125; /** * 无界通配符 * @param list */ public static void unboundedWildcards(List&lt;?&gt; list)&#123; &#125; /** * 下有界通配符 * @param list */ public static void lowerBoundedWildcards(List&lt;? super Integer&gt; list)&#123; &#125; ps: 你可以用通配符指定一个上界，也可以指定一个下界，但不能同时指定。 泛型的限制 不接受基本类型当作参数。 不能通过new泛型来实例化对象，但是可以通过反射来实现。 不能声明静态泛型变量。 不能对泛型参数使用cast或instanceof。 不能创建泛型型数组，比如 1List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2]; // 编译错误 由于类型擦除机制，不能通过泛型重载方法。 123//编译错误 public void print(Set&lt;String&gt; strSet) &#123; &#125;public void print(Set&lt;Integer&gt; intSet) &#123; &#125; ​]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>泛型</tag>
        <tag>Generics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 5，6，7，8，9，10新特性吐血总结]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[作者：拔剑少年 简书地址：https://www.jianshu.com/u/dad4d9675892博客地址：https://it18monkey.github.io转载请注明出处 java5 泛型 (Generics) 1List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); 增强循环（Enhanced for Loop） 1234int[] array = &#123;1, 2, 3, 4, 5&#125;;for (int i : array) &#123; System.out.println(i);&#125; 自动封箱拆箱(Autoboxing/Unboxing )。八大基本类型和它们的包装类能够自动的相互转换。 枚举(Typesafe Enums)。 ps:枚举是一种实现线程安全的单例模式的好方式。 123456enum TestEnum&#123; one, two; TestEnum() &#123; &#125; &#125; 可变参数 (Varargs) 语法：(type... arguments) 可变参数本质仍然是用一个数组存储参数，只是java隐藏了这一过程。需要注意的是如果一个方法声明中含有可变参数，那必须放在最后一个位置。 123456789101112/** * 可变参数测试 * * @param args */ public static void testVarargs(String... args) &#123; //本质就是个数组 System.out.println(args[1]); for (String arg : args) &#123; System.out.println(arg); &#125; &#125; 静态导入（Static Import）。通过import类来使用类里的静态变量或方法（直接通过名字，不需要加上类名.）,简化了代码的书写。 1234//单个导入import static java.lang.Math.PI;//批量导入import static java.lang.Math.*; ps:过去的版本中只能通过继承类或实现接口才能使用。 注解（Annotations）。关键字@interface。 1234567891011//注释注解的注解又叫做元注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyAnnotations &#123; //注解内可以添加方法，也可以不添加 //注解方法的返回值只能是基本类型，String，Class类,枚举,注解,可以有默认值。 int id(); String name() default "whh"; Class classType(); TestEnum enumType();&#125; 新的线程模型和并发库（java.util.concurrent)。 java6 集合框架增强。 为了更好的支持双向访问集合。添加了许多新的类和接口。 新的数组拷贝方法。Arrays.copyOf和Arrays.copyOfRange 12//以下为添加的新接口和类Deque,BlockingDeque,NavigableSet,NavigableMap,ConcurrentNavigableMap，ArrayDeque， ConcurrentSkipListSet ,ConcurrentSkipListMap,ConcurrentSkipListMap ,AbstractMap.SimpleEntry ,AbstractMap.SimpleImmutableEntry Scripting. 可以让其他语言在java平台上运行。 java6包含了一个基于Mozilla Rhino实现的javascript脚本引擎。 支持JDBC4.0规范。 java7 二进制前缀0b或者0B。整型（byte, short, int, long）可以直接用二进制表示。 123//二进制字面值前缀0b 或0B int i = 0b010;//10进制值为2 int j = 0B010; 字面常量数字的下划线。用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾。 12//数字间的下划线不影响实际值 int k = 1_1;//值为11 switch 支持String类型。 泛型实例化类型自动推断。 12Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;(); // 之前Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;(); // 现在 try-with-resources语句。 1234567 /* * 声明在try括号中的对象称为资源，在方法执行完毕后会被自动关闭,相对与之前必须在finally关闭资源，这一特性大大提高了代码的简洁性。 * 所有实现java.lang.AutoCloseable接口的类都作为资源被自动关闭。 */ try (BufferedReader reader=new BufferedReader(new FileReader("d:1.txt")))&#123; return reader.readLine();&#125; 单个catch中捕获多个异常类型（用| 分割）并通过改进的类型检查重新抛出异常。 java8 lambada表达式(Lambda Expressions)。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中)。 方法引用（Method references）。方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法（Default methods）。默认方法允许将新功能添加到库的接口中，并确保兼容实现老版本接口的旧有代码。 重复注解（Repeating Annotations）。重复注解提供了在同一声明或类型中多次应用相同注解类型的能力。 类型注解（Type Annotation）。在任何地方都能使用注解，而不是在声明的地方。 类型推断增强。 方法参数反射（Method Parameter Reflection）。 Stream API 。新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。Stream API集成到了Collections API里。 HashMap改进，在键值哈希冲突时能有更好表现。 Date Time API。加强对日期和时间的处理。 java.util 包下的改进，提供了几个实用的工具类。 并行数组排序。 标准的Base64编解码。 支持无符号运算。 java.util.concurrent 包下增加了新的类和方法。 java.util.concurrent.ConcurrentHashMap 类添加了新的方法以支持新的StreamApi和lambada表达式。 java.util.concurrent.atomic 包下新增了类以支持可伸缩可更新的变量。 java.util.concurrent.ForkJoinPool类新增了方法以支持 common pool。 新增了java.util.concurrent.locks.StampedLock类，为控制读/写访问提供了一个基于性能的锁，且有三种模式可供选择。 HotSpot 删除了 永久代（PermGen）. 方法调用的字节码指令支持默认方法。 java9 java模块系统 （Java Platform Module System）。 新的版本号格式。$MAJOR.$MINOR.$SECURITY.$PATCH java shell，交互式命令行控制台。 在private instance methods方法上可以使用@SafeVarargs注解。 diamond语法与匿名内部类结合使用。 下划线_不能单独作为变量名使用。 支持私有接口方法(您可以使用diamond语法与匿名内部类结合使用)。 Javadoc 简化Doclet API。 支持生成HTML5格式。 加入了搜索框,使用这个搜索框可以查询程序元素、标记的单词和文档中的短语。 支持新的模块系统。 JVM 增强了Garbage-First(G1)并用它替代Parallel GC成为默认的垃圾收集器。 统一了JVM 日志，为所有组件引入了同一个日志系统。 删除了JDK 8中弃用的GC组合。（DefNew + CMS，ParNew + SerialOld，Incremental CMS）。 properties文件支持UTF-8编码,之前只支持ISO-8859-1。 支持Unicode 8.0，在JDK8中是Unicode 6.2。 java10 局部变量类型推断（Local-Variable Type Inference） 12345678910//之前的代码格式URL url = new URL("http://www.oracle.com/"); URLConnection conn = url.openConnection(); Reader reader = new BufferedReader( new InputStreamReader(conn.getInputStream()))//java10中用var来声明变量var url = new URL("http://www.oracle.com/"); var conn = url.openConnection(); var reader = new BufferedReader( new InputStreamReader(conn.getInputStream())); var是一个保留类型名称，而不是关键字。所以之前使用var作为变量、方法名、包名的都没问题，但是如果作为类或接口名，那么这个类和接口就必须重命名了。 var的使用场景主要有以下四种： 本地变量初始化。 增强for循环中。 传统for循环中声明的索引变量。 Try-with-resources 变量。​ Optional类添加了新的方法orElseThrow。相比于已经存在的get方法，这个方法更推荐使用。 java11 支持Unicode 10.0,在jdk10中是8.0。 标准化HTTP Client 编译器线程的延迟分配。添加了新的命令-XX:+UseDynamicNumberOfCompilerThreads动态控制编译器线程的数量。 新的垃圾收集器—ZGC。一种可伸缩的低延迟垃圾收集器(实验性)。 Epsilon。一款新的实验性无操作垃圾收集器。Epsilon GC 只负责内存分配，不实现任何内存回收机制。这对于性能测试非常有用，可用于与其他GC对比成本和收益。 Lambda参数的局部变量语法。java10中引入的var字段得到了增强，现在可以用在lambda表达式的声明中。如果lambda表达式的其中一个形式参数使用了var，那所有的参数都必须使用var。 参考链接： JDK Release Notes What’s New in JDK 8 What’s New in JDK 9 JDK 10 Release Notes JDK 11 Release Notes]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>jdk</tag>
        <tag>java新特性</tag>
      </tags>
  </entry>
</search>
